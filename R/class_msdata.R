#' constructRawLayout
#' 
#' Constructor function for the rawLayout S3 class, holding information on MSdata grouping and layout options in MOSAiC.
#' 
#' @param rawgrouptable a data.frame with columns File and Group , holding file paths and group names, respectively.
#' @param stem if the file paths in rawgrouptable are not full (e.g. subdirectories of the working directory), this should be the path of the working directory.
#' 
#' @export
constructRawLayout <- function(rawgrouptable, stem=NULL){
    
    MSD = list()
    MSD$stem <- stem
    MSD$rawgrouptable <- rawgrouptable
    MSD$filelist <- paste0(stem, rawgrouptable$File)
    MSD$grouping = rawGrouping(data.frame(File = MSD$filelist, Group = rawgrouptable$Group))
    MSD$settings = list(rtw = 30,
                        ppm = 5,
                        cols = 1,
                        colr = 'mosaic.colors',
                        alpha = 0.8)
    
    class(MSD) <- "rawLayout"
    return(MSD)
}

#' updateRawLayout
#' 
#' Updates the file path information in a rawLayout object
#' 
#' @param MSD a rawLayout object with a defined stem
#' @param stem if the file paths in rawgrouptable are not full (e.g. subdirectories of the working directory), this should be the path of the working directory.
#' 
#' @export
updateRawLayout <- function(MSD, new.stem=NULL){
    
    MSD$filelist <- gsub(MSD$stem,new.stem,MSD$filelist)
    MSD$grouping = rawGrouping(data.frame(File = MSD$filelist, Group = MSD$rawgrouptable$Group))
    MSD$stem <- new.stem
    return(MSD)
}


#' loadRawM
#' 
#' TIME CONSUMING. This step does not need to be repeated when adjusting other parameters
#' (e.g. feature list, EIC ppm or RT) Generates an R-readable data structure (a list of xcmsRaw objects) 
#' in memory from MS data files defined in the file list.
#' 
#' Note that there is an xcms function of the same name.
#' 
#' @param filelist a list of mzXML or mzML files (character vector)
#' @param MSn should MSn data be read in? defaults to TRUE
#' @param workers How many cores to use (cf. BiocParallel and SnowParam, argument only used if more than 10 files are loaded).
#' @param rnames names of the xcmsRaw objects in the list returned, defaults to the filepaths of the source files.
#' 
#' @importFrom BiocParallel SnowParam bplapply
#' @importFrom xcms xcmsRaw
#' 
#' @export
##Parallel enabled version for larger number of files
##NOTE: not equivalent to xcms function loadRaw
loadRawM <- function (filelist= mzxml_pos, MSn = T, workers=10, rnames = filelist){

    if (length(filelist)<=10){workers<-1}
    param <- SnowParam(workers = workers)
    rawcoll <- bplapply(filelist,xcmsRaw,  profstep=0, includeMSn = MSn, BPPARAM= param)
    names(rawcoll)<- rnames
    
    return(rawcoll)}



#' rawGrouping
#' 
#' Groups a rawgrouptable into a named list.
#' 
#' @param rawgrouptable a data.frame with columns File and Group , holding file paths and group names, respectively.
#' 
#' @export
rawGrouping <- function(rawgrouptable){
    ## Make list object of grouped column names                                        
    colme <- list()
    for (l in unique(rawgrouptable$Group)){
        colme[[l]] <- as.character(rawgrouptable$File[which(rawgrouptable$Group==l)])
    }
    
    return(colme)
}



#' multiEIC
#' 
#' Extract EICs from multiple files for multiple features.
#' 
#' @param rawdata a (named) list of xcmsRaw objects, e.g. generated by Mosaic::loadRawM
#' @param mz a data.frame with minimum (column 1) and maximum (column 2) m/z values in each row.
#' @param rt a data.frame with minimum (column 1) and maximum (column 2) retention time values (in seconds) in each row.
#' @param rnames names of the rows in the result matrix, typically the row.names of the feature table, or the filenames if byFile =T.
#' @param byFile a data.frame with columns File and Group , holding file paths and group names, respectively.
#' @param XIC deprecated
#' @param getgauss additionally, fit a gauss curve to each EIC (time consuming), defaults to FALSE
#' @param RTcorr if not NULL, this RTcorr object will be used to adjust retention times.
#' 
#' @export
multiEIC <- function (rawdata= rawcoll,
                      mz = data.frame(mzmin = pcame_mini$mzmin, mzmax=pcame_mini$mzmax),
                      rt = data.frame(rtmin = pcame_mini$rt-5, rtmax=pcame_mini$rt+5),
                      rnames = row.names(pcame_mini),
                      byFile = F,#if true, table will be sorted by rawfile, otherwise by feature
                      XIC = F,
                      getgauss = F,
                      RTcorr = NULL
){
  
  if(is.null(rt)){
    sts = lapply(rawdata,slot,"scantime")
    rt <- data.frame(rtmin = rep(min(unname(sapply(sts,min))),nrow(mz)),
                     rtmax = rep(max(unname(sapply(sts,max))),nrow(mz))
    )
  }
  
  mx <- as.matrix(cbind(mz,rt))
  
  if(nrow(mx) ==1){
    mxl <-unname(as.list(data.frame((mx[,1:2]))))
    rxl <-unname(as.list(data.frame((mx[,3:4]))))}
  else{
    mxl <-unname(as.list(data.frame(t(mx[,1:2]))))
    rxl <-unname(as.list(data.frame(t(mx[,3:4]))))
  }    
  
  
  fx3 <- function(ls, mz, rt, rfile, gauss = getgauss, RTcorrx = NULL){
    
    if(!is.null(RTcorrx)){
      ls$rt <- unname(RTcorrx$corr[[which(basename(RTcorrx$fnames) == basename(rfile@filepath@.Data))]])[ls$scan]
    }else{
      ls$rt <- rfile@scantime[ls$scan]
    }
    
    ls$tic <- rfile@tic[ls$scan]
    ls$mzmin <- mz[1]
    ls$mzmax <- mz[2]
    ls$rtmin <- rt[1]
    ls$rtmax <- rt[2]
    ls$intmax <- max(ls$intensity)
    ls$intmin <- min(ls$intensity)
    ls$intsum <- sum(ls$intensity)
    ls$intmean <- mean(ls$intensity)
    if(gauss){
      return(getgauss(ls$intensity))
    }
    return(ls)
  }
  summe <- list()
  if(byFile){
    
    for(i in names(rawdata)){
      rawfile <- rawdata[[i]]
      summe[[i]] <- mapply(rawEICm, mzrange = mxl,
                           rtrange = rxl, MoreArgs=list(object=rawfile), SIMPLIFY = F)
      
      summe[[i]] <- t(mapply(fx3, summe[[i]], mz = mxl,rt=rxl, MoreArgs=list(rfile=rawfile, gauss = getgauss, RTcorrx = RTcorr)))
    }
    return(summe)
    
  }else{
    for(i in c(1:nrow(mz))){
      if(!is.null(rnames)){
        featname <- rnames[i]}
      else{featname <-i}
      
      summe[[featname]] <- mapply(rawEICm, object=rawdata, 
                                  MoreArgs=list(mzrange = mxl[[i]], rtrange = rxl[[i]]), SIMPLIFY = F)
      
      summe[[featname]] <- t(mapply(fx3, summe[[featname]], rfile=rawdata, MoreArgs=list(mz = mxl[[i]],
                                                                                         rt = rxl[[i]],
                                                                                         gauss = getgauss,
                                                                                         RTcorrx = RTcorr
      )
      ))
    }
    return(summe)
  }
}

#' rawEICm
#' 
#' EICs from an xcmsRaw object, modified version of xcms::rawEIC xcmsRaw method.
#' Major difference: Handling of cases where no scan is in rt range.
#' xcms::rawEIC also drops the last scan within range, rawEICm does not.
#' 
#' @param object xcmsRaw object
#' @param mzrange a range of m/z values (numeric(2)).
#' @param rtrange a range of rt values (numeric(2)).
#' @param scanrange a range of scan number values (numeric(2)).
#' @param viewermode True to change handling of out of range rt values for the Mosaic viewer. DEPRECATED (always used)
#' 
#' @export
rawEICm <- function(object,
                                        mzrange = numeric(),
                                        rtrange =numeric(),
                                        scanrange = numeric(),
                    viewermode = T)  {
    #print(paste(mzrange, rtrange))
  
    if (length(rtrange) >= 2 ) {
      
      if(max(rtrange) <= 0){return(list(scan = 1, intensity = numeric(1)))} #quick fix for extreme cases of rt correction (rtmin and rtmax both negative and then set to 0)
            rtrange <- range(rtrange)
            
      #if sccanrange is off, just return EIC for entire range (Viewer only shows the relevant section which then is still empty)
      if(max(object@scantime) < rtrange[2] ){rtrange[2] <- max(object@scantime)}
      if(max(object@scantime) < rtrange[1] ){rtrange[1] <- min(object@scantime)}
            
      
        
        scanidx <- (object@scantime >= rtrange[1]) & (object@scantime <= rtrange[2])
        
        scanrange <- c(match(TRUE, scanidx), length(scanidx) - match(TRUE, rev(scanidx)) + 1 ) # +1 is a fix to include last scan that meets condition, fixes problem if only one scan meets condition
        
        #this is to handle exceptional situations where through retention time correction, the rtmin and rtmax both are between
        if(!any(scanidx) 
           & rtrange[2] <= max(object@scantime) 
           & rtrange[1] >= min(object@scantime)){
          scanrange <- range(c(which.min(abs(object@scantime - rtrange[1])),
                                         which.min(abs(object@scantime - rtrange[2]))))}
        
    }  else if (length(scanrange) < 2){
        scanrange <- c(1, length(object@scantime))}
    else{
        scanrange <- range(scanrange)}
    
    scanrange[1] <- max(1,scanrange[1])
    scanrange[2] <- min(length(object@scantime),scanrange[2]) #this should actually avoid the problem..
    
    if (!is.double(object@env$mz))  object@env$mz <- as.double(object@env$mz)
    if (!is.double(object@env$intensity)) object@env$intensity <- as.double(object@env$intensity)
    if (!is.integer(object@scanindex)) object@scanindex <- as.integer(object@scanindex)
    

    .Call("getEIC",object@env$mz,object@env$intensity,object@scanindex,as.double(mzrange),as.integer(scanrange),as.integer(length(object@scantime)), PACKAGE ='xcms' )


}

#' getgauss
#' 
#' fit a gauss curve into a curve (numeric vector). Note that results will be skewed if scanrate is low or heterogeneous (e.g. ddMS2 experiments).
#' 
#' @param x numeric() to fit the curve
#' 
#' @export
getgauss <- function (x, pval = 1){
    
    
    #substract "baseline"
    summe <- x - min(x)
    
    #normalize intensities to 1
    
    summe <- if(max(x)>0){x/max(x)}else{x}
    
    #here starts the gaussian test, cf. http://www.metabolomics-forum.com/index.php?topic=1031.0 (Krista Longnecker/Tony Larson)
    #fit gauss and let failures to fit through as corr=1
    
    fit <- try(nls(y ~ SSgauss(x, mu, sigma, h), data.frame(x =
                                                                1:length(summe), y = summe)),silent=T)
    gauss <-  if(class(fit) == "try-error")
    {
        0
    } else
    {
        #calculate correlation of summe$intensity against gaussian fit
        if(length(which(!is.na(summe-fitted(fit)))) > 4 &&
           length(!is.na(unique(summe)))>4 && length(!is.na(unique(fitted(fit))))>4)
        {
            cor <- NULL
            options(show.error.messages = FALSE)
            cor <- try(cor.test(summe,fitted(fit),method="pearson",use="complete"))
            options(show.error.messages = TRUE)
            if (!is.null(cor))
            {
                if(cor$p.value <= pval) cor$estimate else 0
            } else 0
        } else 0
        
    }
    return(gauss)}



#' bestgauss
#' 
#' return best gauss curve fit score for any of the files in rawdata for each feature returned by multiEIC.
#' 
#' @param rawdata a (named) list of xcmsRaw objects, e.g. generated by Mosaic::loadRawM
#' @param ... additional arguments passed on to multiEIC().
#' 
#' @importFrom Biobase rowMax
#' 
#' @export
bestgauss <- function(...){
    res <- multiEIC(..., byFile = T, getgauss = T)
    return(data.frame(maxgauss = rowMax(matrix(unlist(res),ncol = length(res)))))
}  

#' exIntensities
#' 
#' Lightweight variant of multiEIC to extract average in a file, more suitable for large featuretables.
#' 
#' @param rawfile an xcmsRaw object
#' @param mz numeric (): m/z values (same length as nrow(rtw)).
#' @param ppm m/z width (+/- ppm from values defined in mz)
#' @param rtw a data.frame with minimum (column 1) and maximum (column 2) retention time values (in seconds) in each row.
#' 
#' @importFrom Biobase rowMax rowMin
#' 
#' @export
exIntensities <- function (rawfile= rawdata[[1]] ,
                           mz = tb$mz,
                           ppm = 5,
                           rtw= data.frame(rta[[1]]$rtmin-5,rta[[1]]$rtmax+5)
                           ){
  
  #cat(paste0("Reference list with ",length(featuretable[,1])," features, iterating through list, feature #" ))
  
  
  mx <- matrix(data= c(mz-ppm*(mz/1000000),
                       mz+ppm*(mz/1000000),
                       rowMin(as.matrix(rtw)),
                       rowMax(as.matrix(rtw))), nrow= length(mz), ncol=4)
  
  mxl <-unname(as.list(data.frame(t(mx[,1:2]))))
  rxl <-unname(as.list(data.frame(t(mx[,3:4]))))
  
  
  summe <- mapply(rawEICm, mzrange = mxl,
                  rtrange = rxl, MoreArgs=list(object=rawfile, scanrange = numeric(), viewermode = F), SIMPLIFY = F)
  
  #substract "baseline" and get rid of scan#
  fx <- function(x) x$intensity-min(x$intensity)
  summe <- lapply(summe, fx )
  
  return(sapply(summe, mean))}

#'multiEICplus
#'
#' get EICs for adducts, isotopes and neutral loss masses
#'
#' @param adducts numeric() of mass shifts
#' @param ... all other arguments passed on to multiEIC
#' 
#' @export
multiEICplus <- function (adducts = c(0,1,2,3),
                          mz,
                          rt,
                          ...
                          #          EICsets = list(mz,
                          #                        rt,
                          #    rnames,
                          #   byFile = F,
                          #  rawdata) #if true, table will be sorted by rawfile, otherwise by feature
                          #
){
  
  liEIC <- list()
  if(is.null(adducts)){adducts <- 0}
  
  for (r in 1:length(adducts)){
    liEIC[[r]] <- mz+adducts[r]
    
  }
  
  res <- sapply(liEIC,multiEIC,rt, ...)
  #  rawdata= EICsets$rawdata,
  
  # rt = EICsets$rt,
  # rnames = EICsets$rnames,
  #byFile = F,#if true, table will be sorted by rawfile, otherwise by feature
  #XIC = F,
  #getgauss = F
  #)
  return(res)
}

#' subsetEICs
#'
#' helper function to subset output from multiEICplus
#'
#' @param EIClist matrix or list of EIC objects
#' @param group file grouping information (named list)
#' 
#' @export
subsetEICs <- function(EIClist,
                       group){
  
  maxEIC <- numeric(1)
  maxTIC <- numeric(1)
  ##subset lines
  for(i in 1:length(EIClist)){
    EIClist[[i]] <- matrix(EIClist[[i]][group,],
                           nrow = length(group),
                           ncol = ncol(EIClist[[i]]),
                           dimnames = list(rows = group,
                                           columns = colnames(EIClist[[i]])))
  }
  
  for(n in 1:length(EIClist)){
 #   if(length(group)==1){
  #    maxEIC <- max(maxEIC,unlist(EIClist[[n]][,"intensity"][[1]]))
   #   maxTIC <- max(maxTIC,unlist(EIClist[[n]][,"tic"][[1]]))
      
  #  }else{
    maxEIC <- max(maxEIC,unlist(EIClist[[n]][,"intensity"]))
    maxTIC <- max(maxTIC,unlist(EIClist[[n]][,"tic"]))
   # }
    }
  
  out <- list(EIClist,maxEIC,maxTIC)
  names(out) <- c("EIClist","maxEIC","maxTIC")
  
  return (out)
}



#' mergeMS
#' 
#' Merge MS spectra by combining peaks that are within a ppm distance
#' 
#' NOTE: If multiple peaks inside a spectrum match another spectrum, only the one with higher(?) mz will be retained
#' 
#' @param speclist data.frame or matrix containing mz and intensity values of a spectrum (mz in column 1)
#' @param ppm accuracy
#' @param mergeOnly if TRUE, only the merged spectrum is returned
#' 
#' @export
mergeMS <- function(speclist,
                    ppm = 5,
                    mergeOnly = F){
  
  #set up the mergeMS object
  res <- list(mz = NULL,
              intensity = NULL,
              #spectra = speclist,
              names = names(speclist),
              counts = NULL,
              merged = NULL
  )  
  
  res$mz <- data.frame(speclist[[1]][,1])
  res$intensity <- data.frame(speclist[[1]][,2])
  class(res) <- "mergeMS"
  
  #merge find common peaks across spectra
  if(length(speclist)>1){
    for (i in 2:length(speclist)){
      #prepare the data frame
      res$mz[,i] <- rep(NA,nrow(res$mz))
      res$intensity[,i] <- rep(NA,nrow(res$mz))
      
      #for first iteration (comparison with spectrum #1), use all mz values
      rest <- speclist[[i]][,1]
      rest_i <- speclist[[i]][,2]
      
      
      #commpare with all previously analyzed spectra
      for (n in seq(i-1)){
        if(length(rest) > 0){
          if(length(rest) == 1){
            dists <- (res$mz[,n] - rest)/rest*1e6
            pos <- which(abs(dists) < ppm, arr.ind = T)
            
            if(length(pos) > 0){
              res$mz[pos,i] <- rest
              res$intensity[pos,i] <- rest_i
              rest <- numeric(0)
              rest_i <- numeric(0)
            }
          }else{
            dists <- sapply(res$mz[,n], "-", rest)/rest*1e6
            pos <- which(abs(dists) < ppm, arr.ind = T)
            res$mz[pos[,2],i] <- rest[pos[,1]]
            res$intensity[pos[,2],i] <- rest_i[pos[,1]]
            
            #keep unmatched entries for next iteration
            if(length(pos[,1]) > 0){ #this prevents bug if there are no hits
              rest <- rest[-pos[,1]]
              rest_i <- rest_i[-pos[,1]]
            }
          }
        }
        
      }
      
      if(length(rest > 0)){
        fill <- (nrow(res$mz)+1):(nrow(res$mz)+length(rest))
        res$mz[fill,] <- NA
        res$intensity[fill,] <- NA
        
        res$mz[fill,i] <- rest
        res$intensity[fill,i] <- rest_i
        
      }
    }
    
    #how many spectra contain each peak?
    res$counts <- BiocGenerics::ncol(res$mz) - BiocGenerics::rowSums(is.na(res$mz))
    
    res$merged <- as.matrix(data.frame(mz = BiocGenerics::rowSums(res$mz*res$intensity, na.rm = T)/BiocGenerics::rowSums(res$intensity, na.rm = T),
                                       intensity = BiocGenerics::rowSums(res$intensity, na.rm = T)/BiocGenerics::ncol(res$mz)
    ))
    
    #order all data in ascending average mz order:
    ord <- order(res$merged[,1])
    
    
    res$mz <- res$mz[ord,]
    res$intensity <- res$intensity[ord,]
    res$counts <- res$counts[ord]
    res$merged <- res$merged[ord,]
    
    
  }else{
    res$counts <- rep(1,length(res$mz[,1]))
    res$merged <- speclist[[1]]
  }
  
  if(mergeOnly){
    return(res$merged)
  }else{
    
    if(length(res$names) == length(speclist)){
      colnames(res$mz) <- basename(res$names)
      colnames(res$intensity) <- basename(res$names)
    }
    
    return(res)
  }
}


#' makeScanlist
#' 
#' Make a scan list
#' 
#' @param splitme character string with format filename:scannumber###filename:scannumber###... as found in gnps networking output tables
#' @param MSData list of xcmsRaw objects. Only scans from files loaded in this object will be returned
#' 
#' @export
makeScanlist <- function(splitme, MSData = NULL){
  pounds <- gregexpr('###',splitme)[[1]]
  pounds <- c(-2,pounds)
  
  subs <- character(length(pounds)-1)
  for(i in seq(length(pounds)-1)){
    subs[i] <- substr(splitme,pounds[i]+3,pounds[i+1]-1)
  }
  
  scantab <- data.frame(file = character(length(subs)),
                        acquisition = integer(length(subs)),
                        scan = integer(length(subs)),
                        rt = numeric(length(subs)),
                        parentMz = numeric(length(subs)),
                        parentIntensity = numeric(length(subs)),
                        stringsAsFactors = F)
  
  for(i in seq(length(subs))){
    colon <- regexpr(':',subs[i])
    scantab$file[i] <- substr(subs[i],1,colon-1)
    scantab$acquisition[i] <- as.integer(substr(subs[i],colon+1,nchar(subs[i])))
    
    if(!is.null(MSData) && sum(basename(names(MSData)) == scantab$file[i]) ==1){
    rawsel <- which(basename(names(MSData)) == scantab$file[i])
    
    
      scantab$file[i] <- basename(names(MSData)[rawsel])
      
      
      scantab$scan[i] <- which(MSData[[rawsel]]@msnAcquisitionNum == scantab$acquisition[i])
      scantab$rt[i] <- MSData[[rawsel]]@msnRt[scantab$scan[i]]
      scantab$parentMz[i] <- MSData[[rawsel]]@msnPrecursorMz[scantab$scan[i]]
      scantab$parentIntensity[i] <- MSData[[rawsel]]@msnPrecursorIntensity[scantab$scan[i]]
      
      
    }
  }
  
  return(scantab)
  
}

#' Parentsearch
#'
#' Make a list of all MS2 scans with the defined parent masses at a given retention time
#' 
#'  @param xcmsRaws list of xcmsRaw objects
#'  @param mz parent mz values (mumeric vector)
#'  @param rt parent retention time (in seconds, numeric vector), needs to be same length as mz
#'  @param ppm parent mz tolerance in ppm
#'  @param rtw parent rt tolerance in seconds
#'
#' @export
Parentsearch <- function (xcmsRaws,
                          mz = c(499.11085),
                          rt = c(366.65),
                          ppm = 5,
                          rtw = 200){
  
  fx <- function(rfile, mz, rt, ppm, rtw){
    
    if(length(rfile@msnPrecursorMz) > 0 ){
      sel <- which( abs((rfile@msnPrecursorMz - mz)) < ppm*mz*1e-6
                    &  abs(rfile@msnRt - rt ) < rtw )
      
      if(length(sel) >0){
        scantab <- data.frame(file = rep( basename(rfile@filepath[[1]]) ,length(sel)),
                              acquisition = rfile@msnAcquisitionNum[sel],
                              scan = sel,
                              rt = rfile@msnRt[sel],
                              parentMz = rfile@msnPrecursorMz[sel],
                              parentIntensity = rfile@msnPrecursorIntensity[sel],
                              charge = rfile@msnPrecursorCharge[sel],
                              ppm = 1e6*(rfile@msnPrecursorMz[sel]-mz)/mz,
                              stringsAsFactors = F)
        
        return(scantab)
      }
    }
    
    
    return(NULL)
  }
  res <- list()
  for(i in length(mz)){
    res <- c(res, lapply(xcmsRaws, fx, mz[i], rt[i], ppm, rtw))
  }
  
  return(data.table::rbindlist(res))
}

